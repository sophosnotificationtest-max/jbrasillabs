<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JBrasil Labs - Cyber Defense 3D</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>

<style>
body {
    margin:0;
    overflow:hidden;
    background:black;
    font-family:monospace;
    cursor:none;
}

#hud {
    position:fixed;
    top:20px;
    left:20px;
    color:#00ff00;
    font-size:14px;
    z-index:10;
}

#start {
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:black;
    color:#00ff00;
    font-size:24px;
    cursor:pointer;
    z-index:20;
}
</style>
</head>

<body>

<div id="hud" style="display:none;">
SCORE: <span id="score">0000</span><br>
LEAKS: <span id="leaks">0</span>/30
</div>

<div id="start">CLICK TO START</div>

<script>
let scene, camera, renderer;
let ship;
let enemies=[];
let bullets=[];
let score=0;
let leaks=0;
let gameActive=false;

// -------- INIT --------
function init(){

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth/window.innerHeight,
        0.1,
        1000
    );
    camera.position.z = 30;

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.PointLight(0x00ff00,2);
    light.position.set(0,20,20);
    scene.add(light);

    const ambient = new THREE.AmbientLight(0x222222);
    scene.add(ambient);

    // Nave
    const geo = new THREE.ConeGeometry(2,6,16);
    const mat = new THREE.MeshStandardMaterial({color:0x00ff00});
    ship = new THREE.Mesh(geo,mat);
    ship.rotation.x = Math.PI/2;
    scene.add(ship);

    window.addEventListener("mousemove", e=>{
        ship.position.x = (e.clientX/window.innerWidth)*40 -20;
        ship.position.y = -(e.clientY/window.innerHeight)*25 +12;
    });

    window.addEventListener("mousedown", shoot);
    window.addEventListener("resize", resize);

    animate();
}

function resize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
}

// -------- ENEMY --------
function spawnEnemy(){
    const geo = new THREE.BoxGeometry(3,3,3);
    const mat = new THREE.MeshStandardMaterial({color:0xff0000});
    const enemy = new THREE.Mesh(geo,mat);
    enemy.position.set((Math.random()-0.5)*40,20,0);
    enemy.speed = 0.15 + score/2000;
    scene.add(enemy);
    enemies.push(enemy);
}

// -------- SHOOT --------
function shoot(){
    if(!gameActive) return;

    const geo = new THREE.CylinderGeometry(0.2,0.2,4);
    const mat = new THREE.MeshBasicMaterial({color:0x00ffff});
    const bullet = new THREE.Mesh(geo,mat);
    bullet.rotation.x = Math.PI/2;
    bullet.position.copy(ship.position);
    bullet.speed=1;
    scene.add(bullet);
    bullets.push(bullet);
}

// -------- LOOP --------
function animate(){
    requestAnimationFrame(animate);

    if(gameActive){

        if(Math.random()<0.02){
            spawnEnemy();
        }

        bullets.forEach((b,bi)=>{
            b.position.y+=b.speed;

            enemies.forEach((e,ei)=>{
                if(b.position.distanceTo(e.position)<2){
                    scene.remove(e);
                    scene.remove(b);
                    enemies.splice(ei,1);
                    bullets.splice(bi,1);
                    score+=10;
                    document.getElementById("score").innerText=
                        score.toString().padStart(4,"0");
                }
            });

            if(b.position.y>25){
                scene.remove(b);
                bullets.splice(bi,1);
            }
        });

        enemies.forEach((e,i)=>{
            e.position.y-=e.speed;
            e.rotation.x+=0.02;
            e.rotation.y+=0.02;

            if(e.position.y<-20){
                scene.remove(e);
                enemies.splice(i,1);
                leaks++;
                document.getElementById("leaks").innerText=leaks;

                if(leaks>=30){
                    resetGame();
                }
            }
        });

    }

    renderer.render(scene,camera);
}

// -------- RESET --------
function resetGame(){
    gameActive=false;
    score=0;
    leaks=0;

    enemies.forEach(e=>scene.remove(e));
    bullets.forEach(b=>scene.remove(b));

    enemies=[];
    bullets=[];

    document.getElementById("score").innerText="0000";
    document.getElementById("leaks").innerText="0";
    document.getElementById("hud").style.display="none";
    document.getElementById("start").style.display="flex";
}

// -------- START --------
document.getElementById("start").addEventListener("click",()=>{
    document.getElementById("start").style.display="none";
    document.getElementById("hud").style.display="block";
    gameActive=true;
});

init();
</script>

</body>
</html>
